<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<!--<script src="node_modules/axios/dist/axios.js"></script>-->
<script>
    //传统异步函数 嵌套越来越深
    // function demo(fn) {
    //     console.log('函数作者做的事(1)');
    //     setTimeout(()=>{
    //         fn();
    //         console.log('jiji(3)');
    //     },1000)
    // }
    //
    // demo(function () {
    //     console.log('自己做的事(2)');
    // })
    //
    // //异步setTimeout 代码结构冗余
    // setTimeout(()=>{
    //     console.log('买菜')
    //     setTimeout(()=>{
    //         console.log('洗菜');
    //         setTimeout(()=>{
    //             console.log('切菜');
    //         },1000)
    //     },1000)
    // },1000)

    //promise 一层嵌套就可以
    // var promise1 = new Promise(function (resolve, reject) {
    //     setTimeout(()=>{
    //         resolve()
    //     },1000)
    // });
    //
    // promise1.then(()=>{
    //     console.log('买菜');
    //     return new Promise((resolve, reject)=>{
    //         setTimeout(()=>{
    //             resolve();
    //         },2000)
    //     })
    // }).then(()=>{
    //     console.log('洗菜');
    //     return new Promise((resolve, reject)=>{
    //         setTimeout(()=>{
    //             resolve()
    //         },1500)
    //     })
    // }).then(()=>{
    //     console.log('切菜');
    // })



    //async await 异步的终极解决方案
    // async function cook() {
    //     //async 后面是 await 等待  等待promise 执行完成才能继续
    //     // await 后面 是promise对象
    //     await  new Promise((resolve,reject)=>{
    //         setTimeout(()=>{
    //             resolve();//async await 都必须要有reslive()解决了
    //             //才会继续向下走
    //         },1000)
    //     });
    //     console.log('买菜');
    //     await new Promise((resolve)=>{
    //         setTimeout(()=>{
    //             resolve();
    //         },2000)
    //     });
    //     console.log('洗菜');
    //     await new Promise((resolve)=>{
    //         setTimeout(()=>{
    //             resolve();
    //         },3000)
    //     })
    //     console.log('切菜');
    // }
    //
    // cook();
    //
    // //axios 返回的就是 promise
    // async function loadResource() {
    //     const res = await axios.get('http://didi.yaojunrong.com/api/article/get');
    //     console.log(res.data);
    // }
    // loadResource().then(()=>{
    //     console.log('所有的异步操作都完成了');    // async本身也是promise
    //
    // });



    //.then(res=>{})
    // async function loadResource() {
    //     const res = await axios.get('http://didi.yaojunrong.com/api/article/get').then(res=>{//.then 后面必有一回调函数  async await 恰好避开了.then
    //只要后面是promise对象 就可以把.then的数据拿出来
    //
    //     });
    //     console.log(res.data);
    // }
    // loadResource();


    //promise 本身有两种状态 resolve成功  reject失败
    var promise = new Promise((resolve, reject)=>{
        console.log('我去赚钱了');
        setTimeout(()=>{
            console.log('赚钱好辛苦');
            reject('资金链断裂')//一旦获取失败 用catch捕捉状态
        },2000)
    });
    promise.then(function () {
        console.log('感谢分红');
    }).catch(e=>{
        // console.log('没分红") 错了 ""
        console.log('没盈利');
        console.log(e);
    })

    // 一、promise的三种状态和基础使用
    // promise有三种状态：pending/reslove/reject 。pending就是未决，resolve可以理解为成功，reject可以理解为拒绝
    let promiseDemo = new Promise((resolve, reject) => {
        // code
        resolve('success')
        // code
        reject('failed')
    })

    promiseDemo.then((result) => {
        console.log(result)
    }, (result) => {
        console.log(result)
    })
    // promise的最终状态会凝固，成功了以后即便再执行reject('failed')状态也不会改变。


    // 我们可以通过Promise.resolve()将一个字符串、数字或者对象等转换成一个成功状态的Promise对象。
    // 从结果上看：将一个promise对象传递给Promise.resolve()方法会被直接返回。





















</script>
</html>